// based on https://landelare.github.io/2023/02/18/dxr-tutorial.html

struct ray_payload {
    color: float3;
    allow_reflection: bool;
    missed: bool;
}

#[set(rayset)]
const scene: bvh;

#[set(rayset), write]
const render_target: tex2d;

const camera: float3 = float3(0, 1.5, -7);
const light: float3 = float3(0, 200, 0);
const sky_top: float3 = float3(0.24, 0.44, 0.72);
const sky_bottom: float3 = float3(0.75, 0.86, 0.93);

fun sendrays(): void {
    var idx: uint2 = ray_index().xy;
    var size: float2 = ray_dimensions().xy;

    var uv: float2 = idx / size;
    var target: float3 = float3((uv.x * 2 - 1) * 1.8 * (size.x / size.y),
                           (1 - uv.y) * 4 - 2 + camera.y,
                           0);

    var primary: ray;
    primary.origin = camera;
    primary.direction = target - camera;
    primary.min = 0.001;
    primary.max = 1000;

    var payload: ray_payload;
    payload.allow_reflection = true;
    payload.missed = false;

    trace_ray(scene, primary, payload);

    render_target[idx] = float4(payload.color.r, payload.color.g, payload.color.b, 1);
}

fun raymissed(payload: ray_payload): void {
    var slope: float = normalize(world_ray_direction()).y;
    var t: float = saturate(slope * 5 + 0.5);
    payload.color = lerp(sky_bottom, sky_top, t);

    payload.missed = true;
}

fun closesthit(payload: ray_payload, uv: float2): void {
    payload.color = float3(1, 0, 1);
}

#[raypipe]
struct ray_pipe {
    gen = sendrays;
    miss = raymissed;
    closest = closesthit;
}
